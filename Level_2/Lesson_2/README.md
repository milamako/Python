# Сегментация опухолей мозга на МРТ с помощью U-Net (BraTS2020)

Проект посвящён задаче сегментации опухолей мозга на МРТ-снимках из датасета BraTS2020 с помощью нейросети U-Net (Keras/TensorFlow). В ноутбуке реализован полный цикл: загрузка и анализ данных, препроцессинг, балансировка, построение и обучение модели, оценка и визуализация результатов.

---

## Краткие тезисы
- **Цель:** Автоматическая сегментация опухолей мозга на МРТ (BraTS2020) с помощью U-Net.
- **Данные:** .h5-файлы, 2D-срезы 240x240, 4 канала (разные типы МРТ), маски 3 канала (разные типы опухоли).
- **Препроцессинг:** Один канал, ресайз до 64x64, нормализация, бинаризация маски, балансировка классов (oversampling).
- **Архитектура:** Классический U-Net (Keras), ~487k параметров, skip connections, выход 64x64x1 (сигмоида).
- **Метрики:** Основная — dice_coef (качество сегментации), также accuracy (для справки).
- **Результаты:** dice_coef ~0.73 (val), accuracy ~0.999. Модель хорошо сегментирует опухоли, особенно крупные.
- **Выводы:** Подход работает, но есть куда расти (размер входа, аугментации, 3D, ensemble).

---

## Описание данных

- **Источник:** [BraTS2020](https://www.kaggle.com/datasets/awsaf49/brats20-dataset-training-validation)
- **Формат:** HDF5 (.h5) — содержит пары 'image' (МРТ) и 'mask' (разметка опухоли)
- **Структура:**
  - image: (240, 240, 4) — 4 типа МРТ
  - mask: (240, 240, 3) — 3 типа опухолевых областей

## Этапы пайплайна

1. **Загрузка и анализ данных**
   - h5py для чтения .h5, matplotlib/seaborn для визуализации.
   - Проверка структуры файлов (ключи: 'image', 'mask').
2. **Препроцессинг**
   - Выбор одного канала (например, FLAIR).
   - Ресайз до 64x64 (tf.image.resize, method='nearest' для масок).
   - Нормализация изображений, бинаризация масок.
3. **Балансировка классов**
   - Oversampling срезов с опухолью для сбалансированного обучения.
   - Стратифицированное разбиение train/val.
4. **Анализ баланса**
   - Barplot распределения классов до/после разбиения.
5. **Архитектура U-Net**
   - Энкодер: Conv2D + MaxPooling2D, увеличение числа фильтров.
   - Bottleneck: Conv2D (128 фильтров).
   - Декодер: UpSampling2D + skip connections.
   - Выход: Conv2D(1, 1, activation='sigmoid').
   - Всего ~487k параметров.
6. **Обучение**
   - 30 эпох, batch_size=8, Adam, binary_crossentropy.
   - Callbacks: ModelCheckpoint, EarlyStopping.
   - Метрики: dice_coef (кастомная), accuracy.
7. **Визуализация результатов**
   - Функция для сравнения исходника, true mask, predicted mask.
   - Примеры срезов с/без опухоли.

## Метрики
- **dice_coef** — основная метрика для сегментации (чувствительна к совпадению масок, стандарт в медицине).
- **accuracy** — для справки (высокая из-за доминирования фона, неинформативна при дисбалансе).
- **binary_crossentropy** — loss для бинарной сегментации.

## Результаты
- **dice_coef:** ~0.77 (train), ~0.73 (val)
- **accuracy:** ~0.999 (val)
- Модель хорошо сегментирует крупные опухоли, иногда теряет мелкие детали.

## Выводы и перспективы
- Подход работает, baseline для BraTS2020.
- Ограничения: малый размер входа, нет аугментаций, только 1 канал, нет кросс-валидации.
- Для улучшения: увеличить размер входа, добавить аугментации, использовать все каналы, попробовать 3D U-Net, ensemble, добавить клинические признаки.
- Код чистый, воспроизводимый, весь пайплайн в Jupyter Notebook.

## Установка и запуск

### Требования
- Python 3.10+
- Установить зависимости:

```bash
pip install -r requirements.txt
```
---